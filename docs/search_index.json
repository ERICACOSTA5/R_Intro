[
["manip.html", "5 Manipular", " 5 Manipular Muchas veces los datos que importamos ya están listos para ser explorados y analizados. Otras veces precisan ser manipulados previamente para ello. En estos casos se parte de un dataset “crudo” y se transforma hacia un dataset “analítico”. tidyr y dplyr integran parte de la colección de paquetes de tidyverse y facilitan la manipulación de los data frames (Wickham and Grolemund 2016) library(tidyverse) Ambos paquetes utilizan el operador %&gt;% (pipe, tubo en español) lo que proporcionan una mejor interpretación lógica: utiliza el resultado de su lado izquierdo como primer argumento de la función del lado derecho (asemejándose a una receta de torta…) x &lt;- c(1, 2, 3, 4) x %&gt;% sum %&gt;% sqrt Su equivalente de código básico es: sqrt(sum(x)) Importemos los datos “crudos” que tenemos almacenados en el archivo .RData load(&quot;./data/datos_curso.RData&quot;) # browseURL(&quot;https://osf.io/jpfet/&quot;) References "],
["tidyr.html", "5.1 tidyr::", " 5.1 tidyr:: Las principales funciones son: gather spread separate unite join join Por lo general en la etapa de toma de datos en el campo/lab (y su consiguiente pasaje a planilla electrónica, excel) nos resulta más cómodo que las planillas de papel tengan un formato wide. En muchas ocasiones necesitamos (para graficar o modelar) que nuestros datos esten en formato long. Veamos de que se tratan ambos formatos. Datos canola: Para analizar el efecto del tratamiento fungicida necesitamos calcular el área bajo la curva (AUC) del progreso de la enfermedad. Para esto vamos a transponer can_phoma al formato “long”. La función gather (del inglés “reunir”, paquete tidyr) apila las columnas que indiquemos. canola %&gt;% gather(`15`, `58`, `95`, `146`, `165`, `180`, `248`, key = &quot;tt&quot;, value = &quot;inc&quot;) %&gt;% # ordenar las columnas select(trt, bk, tt, inc, sev_cank) -&gt; can_long Datos olivo olivo %&gt;% gather(`1`: `30`, key = &quot;tree&quot;, value = &quot;sev&quot;) -&gt; oli_long Datos soja soja %&gt;% gather(key = var, value = val, -fungic) %&gt;% separate(var, c(&#39;bk&#39;, &#39;x&#39;), sep = &#39;_&#39;, convert = TRUE) %&gt;% spread(x, val, convert = TRUE) -&gt; soja_long "],
["dplyr.html", "5.2 dplyr::", " 5.2 dplyr:: Los cinco verbos (funciones) principales de dplyr son: select filter mutate arrange summarise join junta dos data frames a través de puntos en común. Por ejemplo, si queremos unir las variables “sev_check” y “Dis_level” al dataset soja: soja %&gt;% inner_join(by_check, by=&quot;study&quot;) 5.2.1 select Vamos a seleccionar las variables: study, year, cultivar, fungic, rep, sev y yield. soja %&gt;% select(study, year, cultivar, fungic, rep, sev, yield) Es posible usar intervalos de varibles con :. Una selección “negativa” de las variables no deseadas daría un mismo resultado: soja %&gt;% select(-Yld_level, -YR_class, -gr_hab, -sev_check) 5.2.2 filter Semejante a subset. Condiciones separadas por comas equivalen a &amp; de subset. Filtremos la variable fungicida (fungic) por el testigo (ZZ_CHECK) soja %&gt;% select(study:yield) %&gt;% filter(fungic == &#39;ZZ_CHECK&#39;) Ahora, agreguemos el fungicida carbendazim a dosis de 1 litro (CZM[1]) al dataset soja %&gt;% select(study:yield) %&gt;% filter(fungic %in% c(&quot;ZZ_CHECK&quot;,&quot;CZM[1]&quot;)) 5.2.3 mutate Alistar los tipos de variables recien importados Haremos que las variables tipo caracter sean convertidas a factores: soja_long &lt;- soja_long %&gt;% mutate_at(vars(fungic:bk), funs(as.factor)) str(soja_long) summary(soja_long) can_long &lt;- can_long %&gt;% mutate_at(vars(trt, bk), funs(as.factor)) %&gt;% mutate_at(vars(tt, inc), funs(as.numeric)) str(can_long) oli_long &lt;- oli_long %&gt;% mutate_at(vars(loc, farm, tree), funs(as.factor)) str(oli_long) Luego de haber chequeado los tipos de datos con str() agregamos al archivo “datos_curso.RData” los nuevos archivos \"_long\", asi quedan disponibles rápidamente para las siguientes etapas save(soja, canola, mani, olivo, soja_long, can_long, oli_long, file=&quot;data/datos_curso.RData&quot;) Creación de nuevas variables (a partir de las existentes) Muchas variables biológicas no cumplen con los supuestos de las pruebas estadísticas paramétricas: no se distribuyen normalmente, las desviaciones estándar no son homogéneas, o ambas. Hay extensa bibliografia al respecto, recomendando cual transformación es la más adecuada para cada tipo de variable y asi poder ser analizada por un ANOVA tradicional (paramétrico). Como fitopatólogos, la no normalidad es lo predominante. El caso mas común es la severidad de enfermedades que comparamos a través de diferentes tratamientos (cultivar, fungicida, practica de manejo, etc.) Dos transformaciones son mayormente sugeridas para la severidad: Transformacion Arcsine:consiste en tomar el arcoseno de la raiz cuadrada de un numero. Transformación logit: soja1 &lt;- soja %&gt;% select(study:yield) %&gt;% filter(fungic %in% c(&quot;ZZ_CHECK&quot;,&quot;CZM[1]&quot;)) %&gt;% mutate(sev_arc = asin(sqrt(sev/100)), sev_logit = car::logit(sev, percents=TRUE),# log(sev/100/(1-sev/100)), # yield_tn = yield/1000) # browseURL(&quot;http://strata.uga.edu/8370/rtips/proportions.html&quot;) soja &lt;- readr::read_csv(&quot;data/soja_mancha.csv&quot;) soja &lt;- soja %&gt;% mutate_if(is.character, as.factor) 5.2.4 arrange Ordena crecientemente de acuerdo a la columna que le indiquemos. Utilizar desc para orden decrescente. soja1 %&gt;% arrange(year, cultivar) soja1 %&gt;% arrange(year, desc(cultivar)) 5.2.5 summarise Generalmente acompañada de la función group_by la cual permite aplicar un cálculo a las observaciones agrupando por niveles de algún factor (equivale a una tabla dinámica de excel) Veamos cuanto fue el rendimiento promedio y el desvio standard para cada fungicida a través de todos los ensayos: soja %&gt;% group_by(fungic) %&gt;% summarise(yield_mean = mean(yield), yield_sd = sd(yield)) Calculen el rendimiento mínimo y máximo por fungicida Algunas funciones interesantes para la descripción del dataset: n(), n_distinct(). Cuantos ensayos fueron realizados por año: soja %&gt;% group_by(year) %&gt;% summarize(n = n_distinct(study)) Cuantas parcelas tenia cada ensayo: soja %&gt;% group_by(study, year, cultivar) %&gt;% summarize(plots = n()) Adicione una columna de potencial de rendimento del ensayo (rend_pot), considerando el máximo rendimiento observado en ese ensayo. Usando la función ifelse cree una nueva variable categórica “presión de enfermedad” considerando a “sev_check”: Low o High by_check = soja %&gt;% filter(fungic==&quot;ZZ_CHECK&quot;) %&gt;% group_by(study) %&gt;% summarize(sev_check = round(mean(sev, na.rm = TRUE),1)) %&gt;% mutate(Dis_level = ifelse(sev_check &lt; 30, &quot;Low&quot;, &quot;High&quot;)) "],
["forcats.html", "5.3 forcats::", " 5.3 forcats:: Es un excelente aliado para manipular factores, principalmente cuando de graficar se trata. link install.packages(&quot;questionr&quot;) library(forcats) dat %&gt;% mutate(trt1= fct_recode(trt, `Czm` = &quot;CZM[1]&quot;, # `nombre_nuevo` = &quot;nombre_original&quot; `Czm+CM+Tebu` = &quot;CZM_CM_TEBU[1]&quot;, `Epo+Flux+Pyra (0.8L)` = &quot;EPO_FLUX_PYRA[0.8]&quot;, `Check` = &quot;ZZ_CHECK&quot;), trt1= fct_relevel(trt, # Asignar a trt1 nuevo orden de los factores &quot;Check&quot;, &quot;Czm&quot;, &quot;Czm+CM+Tebu&quot;, &quot;Epo+Flux+Pyra (0.8L)&quot;)) %&gt;% ggplot(aes(x, y)) + geom_boxplot()+ "]
]
