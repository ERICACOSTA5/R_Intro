```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      eval=FALSE, 
                      fig.width = 12, 
                      fig.height = 8)
options(width = 90)
```

# Modelo lineal

```{r}
library(tidyverse)
```

```{r}
load("data/datos_curso.RData")
```

  - Exploración  
```{r}
str(soja_long) # tipo de variables
```

```{r}
summary(soja_long) # exploración numérica
```

Para chequear parcelas con datos extraños

```{r}
soja_long %>% 
  ggplot(aes(x=fungic, y=sev)) + 
  geom_text(aes(label = bk), size=3)+  
  coord_flip()
```

```{r}
soja_long %>% 
  ggplot(aes(x=fungic, y=yield)) + 
  geom_text(aes(label = bk), size=3)+  
  coord_flip()
```


- Modelo de efectos fijos

```{r}
m_fix <- lm(sev ~ fungic + bk, data = soja_long)
```

- Diagnósticos

Heterocedasticidad

```{r}
plot(m_fix, which=1)
olsrr::ols_test_score(m_fix)
```

Los residuos se distribuyen normales?

```{r}
hist(m_fix$residuals)
plot(m_fix, which=2)
shapiro.test(m_fix$residuals)
```

**Transformación potencia óptima de boxcox**


Esta transformación solo tiene un parámetro: lambda, graficado en el eje x. Si el valor de lambda es igual a cero, se lleva a cabo la transforma con el logaritmo natural, y si dicho valor es distinto a cero la transformación es potencial. 


![](fig/boxcox.png){width=300px} 

![](fig/boxcox_1.png){width=350px}![](fig/boxcox_02.png){width=350px}

Si el parámetro lambda es igual a uno, no hace falta transformar la variable respuesta. Si el intervalo (lineas punteadas verticales) no contiene a 0 ni a 1, hay que transformar la variable elevando a la potencia del valor de lamba incluido en el intervalo 

La utilización de la transformación Box-Cox requiere que todos los valores de la serie de entrada sean positivos y distintos a cero.
Por ello es adicionada una constante a la variable original (0.5, por ej.)

En el caso de la derecha, el modelo resultaria: 

```{r}
lm((y+0.5)^0.2 ~ trt + bk, ...)
```

```{r}
MASS::boxcox(m_fix)
```

```{r}
anova(m_fix)
```

Modelo mixto con efecto aleatorio del bloque

```{r}
library(lme4)
m_mix <- lmer(sev ~ fungic + (1|bk), data=soja_long)
car::Anova(m_mix)
plot(m_mix)
```

```{r}
library(emmeans)
em <- emmeans(m_mix, ~ fungic, type="response")
em

res.m_mix = CLD(em, 
                Letters = letters, 
                reverse = FALSE)
knitr::kable(res.m_mix)
```
